{"categories":[{"title":"Linux","uri":"https://zhangshunping.github.io/categories/linux/"},{"title":"个人开源项目","uri":"https://zhangshunping.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"title":"网络，安全","uri":"https://zhangshunping.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"title":"语言-golang","uri":"https://zhangshunping.github.io/categories/%E8%AF%AD%E8%A8%80-golang/"}],"posts":[{"content":"[TOC]\n需求背景 ​\t公司的2B业务落地后，应用服务因为一些突发状况出现不在线情况。\n  一些小型客户关注的是SAAS业务，不太关心运维体系，也没有充裕的资源建立一套运维系统。\n  开源组件建立本地版运维体系，较为烦躁。\n  希望能够建立一套健康检测系统，在服务出现问题是，能够到连接到指定的机器上执行HOOK命令；同时根据用户实际情况，建立通知系统。\n由于最近半年在golang方面的东西，因此用golang语言写了一个Healthy健康检测服务，取名为Healthy\n  介绍 Healthy是一个通过golang语言写的服务健康检测服务，再发现连续报错之后会通过ssh协议链接指定的主机上执行Hook指令。同时根据用户自定义的Email开关，实现邮件通知（故障报警，恢复通知，报警冷却）。\n软件架构 - Appservice 服务注册，检测，执行Hook - Sshconnect ssh模块 - Email 报警邮件  Hook操作函数： - 执行cmd命令 - 执行通知事件  安装教程 git clone https://gitee.com/zhangshunping123/Healthy.git go build -o healthy -i main.go chmod +x healthy mv healthy /usr/bin/  使用说明 mkdir -p ~/.health/ cp config.json ~/.health/ $ ./main.exe -h Usage of C:\\Users\\39295\\Desktop\\Healthy\\main.exe: -c string Configfile for service health detection (default \u0026quot;~/.health/config.json\u0026quot;) -e int Number of consecutive health test failures (default 10) -h help -i int Health check interval (default 2)  需要补充  hook interface化 多种 通知方式接入 视图友好  ","id":0,"section":"posts","summary":"[TOC] 需求背景 ​ 公司的2B业务落地后，应用服务因为一些突发状况出现不在线情况。 一些小型客户关注的是SAAS业务，不太关心运维体系，也没有充裕的资","tags":["Golang"],"title":"Healthy","uri":"https://zhangshunping.github.io/2020/06/project-healthy/","year":"2020"},{"content":"[TOC]\n channel，Deadlock死锁的本质 **主协程程阻塞，系统一直等待，导致系统死锁**  场景一： 主协程中使用channel // 1.1 无缓冲channel，读 ch1 := make(chan string) \u0026lt;- ch1 fmt.Println(\u0026quot;ok\u0026quot;) // 1.2 无缓冲channel，写 func main(){ ch1 := make(chan string) ch1 \u0026lt;- \u0026quot;ok\u0026quot; fmt.Println(\u0026quot;ok\u0026quot;) } ##说明： 是因为在同一个主协程中，无缓冲的channel 读和写都是阻塞的，导致系统等待超时，导致deadlock // 2.1 有缓冲读写 func main(){ ch1 := make(chan string,1) ch1 \u0026lt;- \u0026quot;ok\u0026quot; ch1 \u0026lt;- \u0026quot;ok2\u0026quot; fmt.Println(\u0026quot;ok\u0026quot;) } ## 说明： ch1为戴缓冲区1的channel ，写一个ok的时候，主协程不阻塞，写第二个ok2的时候，此时ch1可以看作无缓冲channel，及出现主协程阻塞，导致系统等待，从而deadlock ///修复 //2.1 go 程中使用channel取值 func main(){ ch1 := make(chan string) go func(){ fmt.Println(\u0026quot;ok\u0026quot;,\u0026lt;- ch1) }() ch1\u0026lt;-\u0026quot;ok\u0026quot; time.Sleep(time.Second*1) } //2.2 go程使用channel 赋值 func main(){ ch1 := make(chan string) go func(){ ch1\u0026lt;-\u0026quot;ok\u0026quot; }() fmt.Println(\u0026quot;get from go channle\u0026quot;,\u0026lt;-ch1) } //2.3 注意,如果2.2这样写又会死锁，因为\u0026lt;-ch1在阻塞，导致主协程系统等待 func main(){ ch1 := make(chan string) go func(){ ch1\u0026lt;-\u0026quot;ok\u0026quot; }() fmt.Println(\u0026quot;get from go channle\u0026quot;,\u0026lt;-ch1) fmt.Println(\u0026quot;get2 from go channle\u0026quot;,\u0026lt;-ch1) } //2.4 针对2.3的情况,go程close(ch1)，这样主协程及不会出现等待的情况 func main(){ ch1 := make(chan string) go func(){ ch1\u0026lt;-\u0026quot;ok\u0026quot; close(ch1) }() fmt.Println(\u0026quot;get from go channle\u0026quot;,\u0026lt;-ch1) fmt.Println(\u0026quot;get2 from go channle\u0026quot;,\u0026lt;-ch1) }  场景二：channel遍历导致的deadlock //3.1 range遍历 func main(){ chs := make(chan string, 2) chs \u0026lt;- \u0026quot;first\u0026quot; chs \u0026lt;- \u0026quot;second\u0026quot; for ch := range chs { fmt.Println(ch) } } // 3.2 range遍历修复deadlock func main(){ chs := make(chan string, 2) chs \u0026lt;- \u0026quot;first\u0026quot; chs \u0026lt;- \u0026quot;second\u0026quot; for i:=0;i\u0026lt;=len(chs);i++{ fmt.Println(\u0026lt;-chs) } } //3.3 修复range遍历deadlocak func main(){ chs := make(chan string, 2) chs \u0026lt;- \u0026quot;first\u0026quot; chs \u0026lt;- \u0026quot;second\u0026quot; close(chs) for ch := range chs { fmt.Println(ch) } }  场景三：生产者消费者模型Deadlock //4.1 deadlock func main(){ ch1:=make(chan interface{}) quit:=make(chan bool) // producer go func(){ for i:=0;i\u0026lt;=10;i++{ ch1\u0026lt;-i } }() // comsumer go func(){ for{ fmt.Println(\u0026quot;生产者生产为\u0026quot;,\u0026lt;-ch1) } quit\u0026lt;-true }() \u0026lt;-quit } //说明：是因为quit\u0026lt;-true一直被\u0026lt;-ch1阻塞了，导致了主协程的quit一直阻塞 //4.2改进 func main(){ ch1:=make(chan int) quit:=make(chan bool) // producer go func(){ for i:=0;i\u0026lt;=10;i++{ ch1\u0026lt;-i } }() // comsumer go func(){ for{ select { case num:=\u0026lt;-ch1: fmt.Println(\u0026quot;从管道获取的value是\u0026quot;,num) case \u0026lt;-time.After(3*time.Second): goto loop } } loop: fmt.Println(\u0026quot;loop\u0026quot; ) quit\u0026lt;-true }() \u0026lt;-quit }  ","id":1,"section":"posts","summary":"[TOC] channel，Deadlock死锁的本质 **主协程程阻塞，系统一直等待，导致系统死锁** 场景一： 主协程中使用channel // 1.1 无缓冲ch","tags":["golang-channel"],"title":"Channel 死锁场景总结","uri":"https://zhangshunping.github.io/2020/06/channel-%E6%AD%BB%E9%94%81%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/","year":"2020"},{"content":"四表五链 四表 五链   filter\u0026mdash; 过滤数据包\n  nat \u0026mdash; 用于网络地址转换（IP、端口）\n  raw \u0026mdash; 决定数据包是否被状态跟踪机制处理\n  mangle \u0026mdash;修改数据包的服务类型、TTL、并且可以配置路由实现QOS\n  五链PREROUTING ,INPUT ,OUTPUT ,FORWARD,POSTROUTING\n  命令（增删改查） iptables 查询  -L   iptables -t 表名 -vnL 链名 不指定表名，及为filter表。\n  iptables -vnL --line-number v显示详细说明，n不需要dns解析，\u0026ndash;line-number显示num。\n[root@local-master ~]# iptables -vnL --line-number Chain INPUT (policy ACCEPT 1453 packets, 109K bytes) num pkts bytes target prot opt in out source destination Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) num pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 2108 packets, 146K bytes) num pkts bytes target prot opt in out source destination  //字典解释 pkts：表示匹配的报文个数 bytes:表示报文包的大小 traget:表示规则对应的动作 prot：表示协议 in： 从哪个接口(网卡)流入 out：从哪个接口（网卡）流出 source：表示对应的源头地址，可以是ip也可以是网段 destination：表示对应的目标地址，可以是ip也可以是网段    iptables 管理   增 -I 或者-A\niptables -t 表名 -I 链名 -s -d -j  在首行增加\niptables -t 表名 -I 链名 2 -s -d -j  增加第二行\niptables -t 表名 -A 链名 -s -d -j  在尾行增加\niptables -t filter -I INPUT -s 192.168.2.35 -j ACCEPT\n  删 -D\niptables -t 表名 -D 链名 第几行\niptables -D INPUT 2\n  改 -R\n用-R，但是不建议使用，一般使用先删除，再增加的方式，如果非要用，必须要指定原来的条件\n如果执行\niptables -R INPUT 3 -j REJECT 则会变成这样，把源地址和目的地址都变成0.0.0.0/0 因此要慎用\n使用 -P 修改链路的默认规则\niptables -P INPUT ACCEPT \n  保存规则\niptables-save \u0026gt;/etc/sysconfig/iptables\niptables-restore \u0026lt; /etc/sysconfig/iptables\n  iptables 条件匹配   源地址条件匹配\niptables -I INPUT -s 192.168.129.2,192.168.3.13 -j ACCEPT 用，配置多个源地址\n源地址取反操作 ！\niptables -I INPUT 2 ! -s 192.168.2.244 -j ACCEPT 这个语句的意思是，如果source ip不是192.168.23.2则往下执行。而不是说非192.168.2.2\n  协议匹配\n-p\niptables -I input -s 192.168.2.244 -p tcp -j REJECT 只限制住tcp，但是icmp不限制\n  网卡匹配：-i -o\n-i 只能用在 PREROUTING，INPUT，FORWARD\n-o 只能用在 OUTPUT，POSTROUTING，FORWARD\niptables -I input -s 192.168.2.244 -i eth0 -p icmp -j REJECT  对 网卡 限制ping\n  iptables条件匹配扩展  tcp模块  ​ -p tcp -m tcp \u0026ndash;dport |\u0026ndash;sport 可以指定连续的端口，也可以指定单个端口，如果不指定-m tcp，则用-p的协议作为模块\n#示列 iptables -I INPUT -p tcp -m tcp --dport :25 -j ACCEPT iptables -I INPUT -p tcp --dport 30: -j ACCEPT iptables -I INPUT -p tcp --dport 2000:4000 -j ACCEPT ## 源地址不是22端口的接受 iptables -I INPUT -p tcp -m tcp ! --sport 22 -j ACCEPT #结果如下： 65 3868 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp spt:!22 0 0 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpts:2000:4000 522 26100 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpts:30:65535 154 11068 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpts:0:25    multiport模块\n常用模块，指定离散的多个ip端口，用,隔开\t注意是\u0026ndash;dports和\u0026ndash;sports\n[root@local-master ~]# iptables -I INPUT -p tcp -m multiport --dports 8890,8888 -j DROP [root@local-master ~]# iptables -vnL Chain INPUT (policy ACCEPT 114 packets, 8028 bytes) pkts bytes target prot opt in out source destination 0 0 DROP tcp -- * * 0.0.0.0/0 0.0.0.0/0 multiport dports 8890,8888    iprange模块\n--src-range 指定连续的源地址范围\n--dst-range 指定连续的目的地址范围\n iptables -I INPUT -m iprange --src-range 192.168.2.1-192.168.2.244 -j ACCEPT\n  string 模块 ，过滤关键字\n  time 模块 ， 指定时间放行\n  connlimt模块，限制ip的链接数量\n  limit模块\n--limit-burst 类似“令牌桶”算法，用于指定令牌桶的最大上限\n--limit ，类似\u0026quot;令牌桶\u0026quot;算法，指定令牌桶的生产新令牌的频率，可用时间为second，minute，hour，day\n###例 ##限制ping的速率 // 最大令牌为3个，每一分钟生成30个令牌，相当于每两秒钟生成一个令牌，及每两秒钟放行一个 iptables -I INPUT -p icmp -m limit --limit-burst 3 --limit 30/minute -j ACCEPT //如果iptables 的默认规则为ACCEPT，需要用REJECT做往下匹配限制 iptables -A INPUT -p icmp -j REJECT    ","id":2,"section":"posts","summary":"四表五链 四表 五链 filter\u0026mdash; 过滤数据包 nat \u0026mdash; 用于网络地址转换（IP、端口） raw \u0026mdash; 决定数据包是否被状态跟踪机制处理 mangle \u0026mdash;修改数据包的服务类型、TT","tags":["iptables","防火墙"],"title":"Iptables(一)","uri":"https://zhangshunping.github.io/2020/05/iptables-1/","year":"2020"},{"content":"[TOC]\nstate 模块   对于state模块的连接而言，\u0026ldquo;连接\u0026quot;其中的报文可以分为5种状态，报文状态可以为NEW、ESTABLISHED、RELATED、INVALID、UNTRACKED\n  NEW: 新连接得第一个包为new\n  ESTABLISHED: NEW状态包后面的包的状态理解为ESTABLISHED，表示已建立链接\n  RELATED：有些报文返回是需要多个进程直接相互配合进项，比如FTP服务命令进程和数据进程是有关系的，因此数据链接的报文可能就是RELATED，因为他是由命令进程控制的。\n  INVALID: 报文没有被识别，包没有状态，包的状态INVALID，可以主动屏蔽INVALID的报文\n  UNTRACED:报文没有被追踪，表示无法找到相关的链接\n    因此：客户端，怎样判断这些报文是为了回应我们之前发出的报文，还是主动向我们发送的报文呢？\niptables -t fiflter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT  则表示，客户端不允许被主动发起报文。\n黑白名单   方式一：（不推荐）设置链路的默认规则为DROP\\\n##1、 设置链路的默认规则为Drop iptables -P INPUT DROP ##2、放行 iptables -I INPUT --dport 80 -j ACCEPT ## 问题 如果不小心执行iptahles -F 的会导致所有请求无法访问    方式二：（推荐）设置链路的默认规则为ACCEPT，在末尾设置DROP\niptables -P INPUT -j ACCEPT iptables -I INPUT --dport 80 -j ACCEPT iptables -A INPUT -j DROP    自定义链路 创建自定义链路 #1. -N 创建自定义表 iptables -t filter -N IN_WEB #2. 常看自定义表 iptables --line -vnL IN_WEB ##显示如下 ： 0 references 表示没有被引用  #3、在默认链路上引用IN_WEB ## 在INPUT链路上插入规则，表示访问80的端口，跳转到IN_WEB自定义链路上 iptables -I INPUT -p tcp --dport 80 -j IN_WEB [root@k8s-master01 ~]# iptables -vnL INPUT Chain INPUT (policy ACCEPT 273 packets, 24366 bytes) pkts bytes target prot opt in out source destination 2 120 IN_WEB tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 8339 783K KUBE-EXTERNAL-SERVICES all -- * * 0.0.0.0/0 0.0.0.0/0 ctstate NEW /* kubernetes externally-visible service portals */ 828K 177M KUBE-FIREWALL all -- * * 0.0.0.0/0 0.0.0.0/0 [root@k8s-master01 ~]# iptables -vnL IN_WEB Chain IN_WEB (1 references) ## 这里的 references为1 表示被引用一次 pkts bytes target prot opt in out source destination 2 120 REJECT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 reject-with icmp-port-unreachable [root@k8s-master01 ~]# curl 127.0.0.1 curl: (7) Failed connect to 127.0.0.1:80; 拒绝连接  重命名自定义链路 -E [root@k8s-master01 ~]# iptables -E IN_WEB IN_WEB2 [root@k8s-master01 ~]# iptables -vnL INPUT Chain INPUT (policy ACCEPT 63 packets, 5259 bytes) pkts bytes target prot opt in out source destination 4 240 IN_WEB2 tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 8491 798K KUBE-EXTERNAL-SERVICES all -- * * 0.0.0.0/0 0.0.0.0/0 ctstate NEW /* kubernetes externally-visible service portals */ 828K 177M KUBE-FIREWALL all -- * * 0.0.0.0/0 0.0.0.0/0 [root@k8s-master01 ~]# iptables -vnL IN_WEB2 Chain IN_WEB2 (1 references) pkts bytes target prot opt in out source destination 4 240 REJECT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 reject-with icmp-port-unreachable  删除自定义链路 -X ##删除链路需要满足 ## 1、自定义链没有被任何默认链引用，即自定义链的引用计数为0。 ##2、自定义链中没有任何规则，即自定义链为空。 [root@k8s-master01 ~]# iptables -X IN_WEB2 iptables: Too many links. [root@k8s-master01 ~]# iptables -D INPUT 1 ## 清空引用链路 [root@k8s-master01 ~]# iptables -X IN_WEB2 iptables: Directory not empty. [root@k8s-master01 ~]# iptables -F IN_WEB2 ## 清空规则 [root@k8s-master01 ~]# iptables -X IN_WEB2  Iptables网络防火墙 1、需求： 主机A访问主机C，A和C不在同一个网络，借助主机B的iptables路由规则 ##主机A,添加路由，去往192.168.181.0（外网）的报文的下一跳为主机B route add -net 192.168.181.0/24 gw 192.168.2.17 ##主机C，添加路由，去往192.168.2.0(外网的报文)的下一跳为主机B route add -net 192.168.2.0/24 gw 192.168.2.17 ## 主机B 永久开启路由转发 vim /etc/sysctl.conf net.ipv4.ip_forward ## 临时开启 echo 1 \u0026gt;/proc/sys/net/ipv4/ip_forward ##主机B设置黑名单 iptables -t filter -P FORWARD ACCEPT iptables -A FORWARD DROP iptables -E FORWARD_TEST iptables -I FORWARD_TEST -s 192.168.2.0/24 -j ACCEPT iptables -I FORWARD_TEST -s 192.168.181.0/24 -j ACCEPT iptables -I FORWARD -j FORWARD_TEST  2、通过snat，dnat转发。实现公网端口暴露和私网上网  模型如下，主机A为公网客户都安，主机B为公司iptables linux，主机C为内网主机    操作步骤\n#主机B需开启路由 vim /etc/sysctl.conf net.ipv4.ip_forward # 添加snat配置(允许私网通过B主机的ip，访问A) iptables -t nat -I POSTROUTING -s 192.168.181.0/24 -j SNAT --to-source=192.168.2.17 # 添加dnat配置（A访问B的122端口，即可访问C主机的22端口 iptables -t dnat -I PREROUTING -d 192.168.2.18 -p tcp --dport 122 --to-destination=192.168.181.129:22 ##同时检查 filter表上是否有限制操作 iptables -t filter -vnL FORWARD ## 主机c需要添加路由 route add default gw 192.168.181.128    dnat和snat转发，普通路由转发的区别   共同点\n 都需要linux 开启路由转发功能 私有主机，及C主机都需要配置下一跳到B主机    不同点\n  dnat和snat 是描述的私网和公网的情况，因此主机A配置route 到B是广播不可达的；而但单纯的路由转发一般在同一二层网络中（比如vmware开启三台主机）\n  dnat和snat 完成的地址转换，经过B主机之后，ip的地址都会变成B主机的地址；而单纯的路由转发，ip地址不变\n  MASQUSEADE  可以把MASQUERADE理解为动态的、自动化的SNAT，如果没有动态SNAT的需求，没有必要使用MASQUERADE，因为SNAT更加高效。  iptables -t nat -I POSTROUTING -s 192.168.181.0/24 -o ens32 -j MASQUSEADE  REDIRECT动作可以在本机上进行端口映射   比如，将本机的80端口映射到本机的8080端口上\niptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080\n经过上述规则映射后，当别的机器访问本机的80端口时，报文会被重定向到本机的8080端口上。\nREDIRECT规则只能定义在PREROUTING链或者OUTPUT链中。\n  iptables 注意点：  针对相同服务的时候，严格的规则应该放在前面 当规则中有多个匹配条件时，条件之间默认存在\u0026quot;与\u0026quot;的关系 在不考虑1的情况下，应该将更容易被匹配到的规则放置在前面，通过iptables -vnL 查看（pkts计数） 当IPTABLES所在主机作为网络防火 墙时，在配置规则时，应着重考虑方向性，双向都要考虑，从外到内，从内到外 设置防护墙白名单的时候，默认规则应为ACCEPT，在某行增加DROP动作，防止iptables -F 导致不可登陆  ","id":3,"section":"posts","summary":"[TOC] state 模块 对于state模块的连接而言，\u0026ldquo;连接\u0026quot;其中的报文可以分为5种状态，报文状态可以为NEW、ESTABLISHED","tags":["iptables","防火墙"],"title":"Iptables(二)","uri":"https://zhangshunping.github.io/2020/05/iptables-2/","year":"2020"},{"content":"channle 都是应用于两个go程，一个读，一个写  channel 具有阻塞的作用，类似go程之间对同步资源进行锁机制 具有数据传递的功能  一、无缓冲channel \u0026mdash;-（同步） 无缓冲channel 定义  var ch =make(chan string ) 或者ch :=make(chan string)  无缓冲channel的说明  ch \u0026lt;- \u0026ldquo;hehe\u0026rdquo; 写数据，数据没有被在读，则为阻塞 \u0026lt;-ch 读数据，数据没有没有在写， 则为阻塞 len(ch) ：channel中未读取的元素个数，cap(ch):channel中通道的容量 。 都是零  二、有缓冲channel \u0026mdash;\u0026mdash;（异步） 有缓冲channel定义  var ch =make(chan string ,3) 或者ch :=make(chan string ,3) 当存储的元素个数超过了cap(ch) 才会阻塞  三、关闭channel   close(ch) ，不再向对端发送数据\n  判断chan是否关闭 ，\nif num,ok:=\u0026lt;-chan; ok ==true{ fmt.Println(\u0026quot;已经关闭\u0026quot;) } // 无缓冲 关闭channle，读端 ok为false，num为0 // 如果channel已经关闭 ，写端出现panic send on closed channel // 如果channle有缓冲，当len(ch) 的值没有超过cap(ch),那么close(ch)是阻塞的 // 如果channle无缓冲，当ch中存在元素，close（ch）也是阻塞的 func main() { ch:=make(chan int) go func() { for i:=0;i\u0026lt;=100;i++{ ch \u0026lt;-i } close(ch) //这里close其实是阻塞的 }() go func() { for{ if num,ok:=\u0026lt;-ch;ok{ fmt.Print(num) close(ch) }else{ fmt.Println(\u0026quot;jieshu\u0026quot;,num) } } }()    四、单向channel   双向channel ch:=make(chan string )\n  单项写channel var readCh chan\u0026lt;- int\n  单向读channel var writech \u0026lt;-chan\n  单向channel和双向channel转换  双向转单向 readch = ch 单向不可以转双向  传参：传【引用】 Channel通信的时候，要保证channle不能在同一个go程之中\n五、消费者，生产者模型  解耦（降低消费者和生产者直接的耦合度） 并发（消费者，生产者消费不对等，能保持正常的通信） 缓存（生产者和消费者处理不一致时，暂存数据）  生产者，消费者实现：  - 有缓冲的channel ：异步同行 - 无缓冲的channel：同步通信  package main import \u0026quot;fmt\u0026quot; type Orderinfo struct { id int price int } func producer(ch chan\u0026lt;- Orderinfo) { for i:=0;i\u0026lt;=1000;i++{ ch\u0026lt;-Orderinfo{id:i+1,price: 10} } close(ch) } func consumer(ch \u0026lt;-chan Orderinfo) { for order:=range(ch){ fmt.Println(\u0026quot;订单价格：\u0026quot;,order.price,\u0026quot;订单编号：\u0026quot;,order.id) } } func main() { ch :=make(chan Orderinfo) go producer(ch) consumer(ch) }  六、定时器: 三种定义方法 time.sleep() ; time.NewTimer() ;time.After() package main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { //time.sleep定时 fmt.Println(\u0026quot;当前时间\u0026quot;,time.Now()) time.Sleep(time.Second*1) fmt.Println(\u0026quot;time.sleep定时当前时间\u0026quot;,time.Now()) //time.Newtimer // 创建定时器 t:=time.NewTimer(time.Second*1) now:=\u0026lt;-t.C fmt.Println(\u0026quot;time.NewTimer阻塞 t.C管道读取系统当前时间为：\u0026quot;,now) //time.After 返回一个管道 now=\u0026lt;-time.After(time.Second) fmt.Println(\u0026quot;time.After，系统chan写满，则返回当前时间：\u0026quot;,now) }  七、select 语句 select (退出for 循环中的select ，用return 或者goto的方式)\nfunc main() { ch:=make(chan int) quit:=make(chan bool) fmt.Println(\u0026lt;-time.After(time.Second)) go func() { for{ select { case num:=\u0026lt;-ch: fmt.Println(\u0026quot;nume\u0026quot;,num) case \u0026lt;-time.After(time.Second*3): fmt.Println(\u0026quot;超时\u0026quot;) quit\u0026lt;-true //return goto loop } } loop: fmt.Println(\u0026quot;for end\u0026quot;) }() for i:=0;i\u0026lt;4;i++{ ch\u0026lt;-i time.Sleep(time.Second) } \u0026lt;-quit }  八、锁 golang死锁模型：  1、单go程自己死锁： channel至少在两个go程中使用，否则思索 2、go程间channel访问顺序：使用channle一端写（读），要保证另一一段读（写），同时有机会执行，否则思索 3、多go程，多channel交叉死锁 4、在go语言中，尽量不要将互斥锁和channel一起使用，会造成隐形死锁  golang 锁  1.channel 定义互斥锁  //定义个全局channel var ch =make(chan string) func Printer(s string){ for _,s1:=range(s){ fmt.Print(string(s1)) \u0026lt;-time.After(time.Microsecond*500000) } } func main() { //go程里结束，向ch中传递 go func() { Printer(\u0026quot;hello\u0026quot;) ch\u0026lt;-\u0026quot;ok\u0026quot; close(ch) }() // 主go程在阻塞等待 \u0026lt;-ch Printer(\u0026quot;world\u0026quot;) }    2.用锁定义互斥锁（这种锁，我们一般称为:\u0026ndash;\u0026gt;建议锁)\nvar mutex sync.Mutex //定义锁 //对共享资源枷锁 mutex.Lock() fmt.Pirnt('hello') muter.Unlock()    3.读写锁: 读时共享，写时独占（写比读优先级要高）\n var rwmutex2 sync.RWMutex 定了一把锁，这个锁带有读和写的属性  var rwmutex2 sync.RWMutex var I int func reader2(i int){ for{ // 读锁，并发共享 rwmutex2.RLock() a:=I rwmutex2.RUnlock() fmt.Printf(\u0026quot;=======第%d个读进程,读取到%d\\n\u0026quot;,i,a) time.Sleep(time.Second) } } func writer2(a int){ for{ num:=rand.Intn(100) // 写锁，独占 rwmutex2.Lock() I=num fmt.Printf(\u0026quot;第%dth写go程,写数据:%d \\n\u0026quot; ,a,num) time.Sleep(time.Second*2) rwmutex2.Unlock() } } func main(){ for i:=0;i\u0026lt;=3;i++{ go reader2(i) } for i:=0;i\u0026lt;=3;i++{ go writer2(i) } for{ ; } }   channel 无法完成共享读，因此需要对读完成共享数据读的时候，使用读写锁    条件变量 type Cond struct   适用生产者消费者模型：本身不是锁，经常要与锁结合使用,他是一个结构体\n  作用：\n 加锁 访问公共区域（比如带缓冲channle） 解锁 唤醒阻塞在条件变量上对端    条件变量Cond常见方法：\n  wait（） 函数 使用场景\n 阻塞等待条件变量满足 释放已掌握的互斥锁相当于 cond.L.Unlock() ;注意：两步分为原子操作 \u0026lt;\u0026mdash;-及不可以分开 当被唤醒，Wati（）函数返回时候，解决阻塞并重新获取互斥锁。相当于cond.L.Lock()    cond.Single() 唤醒对端\n  cond.Broadcast()惊群唤醒\n    创建条件变量流程\n//1.创建条件变量 var cond sync.Cond //2.创建条件变量指定锁 cond.L=new(sync.Mutex) //3. 给公共区加锁 cond.L.Lock() //4.判断是否达到阻塞条件 // //4.1 producer 端判断条件 for len(ch)==cap(ch){ cond.Wait() //1.阻塞2.解锁 3.加锁 } //4.2 consumer端判断 for len(ch)==0{ cond.Wait() } //5.访问公共区，读写，打印 //6.对公共区条件变量解锁 cond.L.Unlock() //7.唤醒阻塞在条件变量对端 cond.Single()  【条件变量示例】\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) //1.创建条件变量 var cond sync.Cond func producer2(product chan\u0026lt;- string,index int) { //3.使用条件变量给公共区加锁 cond.L.Lock() //4. 判断是否已经填满缓冲区，如果填满则wait() for len(product)==cap(product){ cond.Wait() } //5.执行写操作 str:=fmt.Sprintf(\u0026quot;produce%d\u0026quot;,index) product\u0026lt;-str fmt.Printf(\u0026quot;这是第%d个producer进程,produce %q \\n\u0026quot;,index,str) time.Sleep(time.Millisecond*200) // 6.解锁 cond.L.Unlock() //7.唤醒阻塞的对端 cond.Signal() } func consumer2(product \u0026lt;-chan string,index int) { for{ cond.L.Lock() for len(product)==0{ cond.Wait() } str\t:=\u0026lt;-product fmt.Printf(\u0026quot;--------这是第%d个consumer进程,consum %s \\n\u0026quot;,index,str) cond.L.Unlock() cond.Signal() } } func main() { product:=make(chan string,3) // 2.指定条件变量用的锁为互斥锁 cond.L=new(sync.Mutex) for i:=1;i\u0026lt;=1000;i++{ go producer2(product,i) } for i:=1;i\u0026lt;=3;i++{ go consumer2(product,i) } for{ ; } }    ","id":4,"section":"posts","summary":"channle 都是应用于两个go程，一个读，一个写 channel 具有阻塞的作用，类似go程之间对同步资源进行锁机制 具有数据传递的功能 一、无缓冲channel \u0026mda","tags":["golang-channel","web并发"],"title":"Golang-Channel","uri":"https://zhangshunping.github.io/2020/05/golang-channel/","year":"2020"},{"content":" rysnc 常用选项 rsync常用选项 -a 包含-rtplgoD -r 同步目录时要加上，类似cp时的-r选项 -v 同步时显示一些信息，让我们知道同步的过程 -l 小写l保留软连接，例如A机器上面的文件有软连接所指向的文件，同步到B机器时同样也保留软连接。 -L 大写L加上该选项后，同步软链接时会把源文件给同步 -p 小写p保持文件的权限属性 -o 保持文件的属主 -g 保持文件的属组 -D 保持设备文件信息 -t 保持文件的时间属性 --delete 删除DEST中SRC没有的文件 --exclude 过滤指定文件，如--exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步 -P 大写P显示同步过程，比如速率，比-v更加详细 -u 加上该选项后，如果DEST中的文件比SRC新，则不同步 -z z表示zip传输时压缩，传输到目标点后自动就解压了，只是在传输前或传输过程中减少网络资源带宽。 --existing ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。 --ignore-existing：要求只更新目标端不存在的文件。和\u0026quot;--existing\u0026quot;结合使用有特殊功能，见下文示例。 --delete ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意\u0026quot;--delete\u0026quot;是在接收端执行的，所以它是在 ：exclude/include规则生效之后才执行的。 -d --dirs ：以不递归的方式拷贝目录本身。默认递归时，如果源为\u0026quot;dir1/file1\u0026quot;，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。 -u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。  常用命令 拷贝复制   ## 将/home/bridg.war 增量同步到/tmp/下 命名为bridge2.war rsync -Pzav /home/bridge.war /tmp/bridge2.war ## 将/home/bridg.war 增量同步到/tmp/ rsync -Pzav /home/bridge.war /tmp/ ## --delete的使用 ，删除DEST中SRC没有的文件 ##注意：src目录没有的，dst目录也会被删掉 [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# tree ./ ./ ├── t1 │ ├── a │ ├── b │ └── c └── t2 ├── a └── c [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# rsync -Pzav --delete t2/ t1/ [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# tree ./ ./ ├── t1 │ ├── a │ └── c └── t2 ├── a └── c    过滤 --exclude\n[root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# ll t2/ 总用量 0 -rw-r--r-- 1 root root 0 5月 21 11:35 a -rw-r--r-- 1 root root 0 5月 21 11:35 c [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# ll t1/ 总用量 0 -rw-r--r-- 1 root root 0 5月 21 11:35 a -rw-r--r-- 1 root root 0 5月 21 11:35 c -rw-r--r-- 1 root root 0 5月 21 11:41 jss.js -rw-r--r-- 1 root root 0 5月 21 11:41 readme.txt [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# rsync -av --exclude \u0026quot;*.js\u0026quot; --exclude \u0026quot;*.txt\u0026quot; t1/ t2/ ## 显示结果js和txt并未拷贝 [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# ll t2/ 总用量 0 -rw-r--r-- 1 root root 0 5月 21 11:35 a -rw-r--r-- 1 root root 0 5月 21 11:35 c [root@k8s-master01 /tmp/tmp.V8GRsfNIeG]# ll t1/ 总用量 0 -rw-r--r-- 1 root root 0 5月 21 11:35 a -rw-r--r-- 1 root root 0 5月 21 11:35 c -rw-r--r-- 1 root root 0 5月 21 11:41 jss.js -rw-r--r-- 1 root root 0 5月 21 11:41 readme.txt    使用sshpasss, ssh 远程同步\nsshpass -p 123123 rsync -av -e \u0026quot;ssh -p 22\u0026quot; root@127.0.0.1:/tmp/t2/ /tmp/t1/    ​\n  使用rsync 删除大文件\n## 在遇到很大的目录时候，使用rm去删除，会出现报错 ##先创建一个空目录 mkdir /tmp/empty/ ## 清空目标目录 # rsync --delete-before -avH --progress --stats /tmp/empty/ /var/spool/postfix/maildrop rsync --delete -rlptD /tmp/empty/ /var/spool/postfix/maildrop/ ##选项说明： -delete-before 接收者在传输之前进行删除操作 –progress 在传输时显示传输过程 -a 归档模式，表示以递归方式传输文件，并保持所有文件属性 -H 保持硬连接的文件 -v 详细输出模式 –stats 给出某些文件的传输状态 ## 注意： ## 不过在使用上面的命令进行清理时，存在一个问题，清空后，目标目录的权限会和源目录的权限一样。如：/tmp/empty是root：root，而maildrop之前是postfix：postdrop ，执行之后也会maildrop目录的权限也会变成root：root 。由于-a权限是-rlptogD几个参数的集合，所以可以将og（owner:group）两个参数去掉。清空时自动保持之前的目录权限，如下： rsync --delete -rlptD /tmp/empty/ /var/spool/postfix/maildrop/    ","id":5,"section":"posts","summary":"rysnc 常用选项 rsync常用选项 -a 包含-rtplgoD -r 同步目录时要加上，类似cp时的-r选项 -v 同步时显示一些信息，让我们知道同步的过程 -l 小写l","tags":["Linux","rync"],"title":"Rsync","uri":"https://zhangshunping.github.io/2020/05/rsync/","year":"2020"}],"tags":[{"title":"Golang","uri":"https://zhangshunping.github.io/tags/golang/"},{"title":"golang-channel","uri":"https://zhangshunping.github.io/tags/golang-channel/"},{"title":"iptables","uri":"https://zhangshunping.github.io/tags/iptables/"},{"title":"Linux","uri":"https://zhangshunping.github.io/tags/linux/"},{"title":"rync","uri":"https://zhangshunping.github.io/tags/rync/"},{"title":"web并发","uri":"https://zhangshunping.github.io/tags/web%E5%B9%B6%E5%8F%91/"},{"title":"防火墙","uri":"https://zhangshunping.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"}]}